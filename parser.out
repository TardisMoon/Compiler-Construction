Grammar:

Rule 0     S' -> program
Rule 1     program -> expr
Rule 2     program -> INT MAIN LPAREN RPAREN LCB stmt_list return_stmt RCB
Rule 3     stmt_list -> stmt
Rule 4     stmt_list -> stmt stmt_list
Rule 5     stmt -> LPAREN expr RPAREN
Rule 6     stmt -> <empty>
Rule 7     stmt -> ID ASSIGN NUM SEMI
Rule 8     stmt -> INT ID SEMI
Rule 9     stmt -> INT ID ASSIGN expr SEMI
Rule 10    return_stmt -> RETURN factor SEMI
Rule 11    expr -> factor
Rule 12    expr -> factor / expr  [precedence=left, level=2]
Rule 13    expr -> factor * expr  [precedence=left, level=2]
Rule 14    expr -> factor - expr  [precedence=left, level=1]
Rule 15    expr -> factor + expr  [precedence=left, level=1]
Rule 16    factor -> ID
Rule 17    factor -> NUM

Unused terminals:

    AUTO
    CHAR
    NOTEQ
    ENUM
    WHILE
    STATIC
    FLOAT
    GRTEQ
    VOLATILE
    NEGATE
    CONTINUE
    INCRMNT
    REGISTER
    LONG
    ELSE
    DEFAULT
    LOGICOR
    STRUCT
    INLINE
    COMPLEX
    DECREMNT
    BOOL
    SHORT
    UNION
    IF
    EXTERN
    LESEQ
    SIZEOF
    CASE
    SWITCH
    VOID
    TYPEDEF
    BREAK
    SIGNED
    IMAGINARY
    LTR
    LOGICAND
    FOR
    DOUBLE
    UNSIGNED
    CONST
    DO
    GOTO
    EQREL
    GTR

Terminals, with rules where they appear:

*                    : 13
+                    : 15
-                    : 14
/                    : 12
ASSIGN               : 7 9
AUTO                 : 
BOOL                 : 
BREAK                : 
CASE                 : 
CHAR                 : 
COMPLEX              : 
CONST                : 
CONTINUE             : 
DECREMNT             : 
DEFAULT              : 
DO                   : 
DOUBLE               : 
ELSE                 : 
ENUM                 : 
EQREL                : 
EXTERN               : 
FLOAT                : 
FOR                  : 
GOTO                 : 
GRTEQ                : 
GTR                  : 
ID                   : 7 8 9 16
IF                   : 
IMAGINARY            : 
INCRMNT              : 
INLINE               : 
INT                  : 2 8 9
LCB                  : 2
LESEQ                : 
LOGICAND             : 
LOGICOR              : 
LONG                 : 
LPAREN               : 2 5
LTR                  : 
MAIN                 : 2
NEGATE               : 
NOTEQ                : 
NUM                  : 7 17
RCB                  : 2
REGISTER             : 
RETURN               : 10
RPAREN               : 2 5
SEMI                 : 7 8 9 10
SHORT                : 
SIGNED               : 
SIZEOF               : 
STATIC               : 
STRUCT               : 
SWITCH               : 
TYPEDEF              : 
UNION                : 
UNSIGNED             : 
VOID                 : 
VOLATILE             : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear:

expr                 : 1 5 9 12 13 14 15
factor               : 10 11 12 13 14 15
program              : 0
return_stmt          : 2
stmt                 : 3 4
stmt_list            : 2 4


state 0

    (0) S' -> . program
    (1) program -> . expr
    (2) program -> . INT MAIN LPAREN RPAREN LCB stmt_list return_stmt RCB
    (11) expr -> . factor
    (12) expr -> . factor / expr
    (13) expr -> . factor * expr
    (14) expr -> . factor - expr
    (15) expr -> . factor + expr
    (16) factor -> . ID
    (17) factor -> . NUM
    INT             shift and go to state 3
    ID              shift and go to state 5
    NUM             shift and go to state 6

    program                        shift and go to state 1
    expr                           shift and go to state 2
    factor                         shift and go to state 4

state 1

    (0) S' -> program .


state 2

    (1) program -> expr .
    $end            reduce using rule 1 (program -> expr .)


state 3

    (2) program -> INT . MAIN LPAREN RPAREN LCB stmt_list return_stmt RCB
    MAIN            shift and go to state 7


state 4

    (11) expr -> factor .
    (12) expr -> factor . / expr
    (13) expr -> factor . * expr
    (14) expr -> factor . - expr
    (15) expr -> factor . + expr
    $end            reduce using rule 11 (expr -> factor .)
    RPAREN          reduce using rule 11 (expr -> factor .)
    SEMI            reduce using rule 11 (expr -> factor .)
    /               shift and go to state 8
    *               shift and go to state 9
    -               shift and go to state 10
    +               shift and go to state 11


state 5

    (16) factor -> ID .
    /               reduce using rule 16 (factor -> ID .)
    *               reduce using rule 16 (factor -> ID .)
    -               reduce using rule 16 (factor -> ID .)
    +               reduce using rule 16 (factor -> ID .)
    $end            reduce using rule 16 (factor -> ID .)
    RPAREN          reduce using rule 16 (factor -> ID .)
    SEMI            reduce using rule 16 (factor -> ID .)


state 6

    (17) factor -> NUM .
    /               reduce using rule 17 (factor -> NUM .)
    *               reduce using rule 17 (factor -> NUM .)
    -               reduce using rule 17 (factor -> NUM .)
    +               reduce using rule 17 (factor -> NUM .)
    $end            reduce using rule 17 (factor -> NUM .)
    RPAREN          reduce using rule 17 (factor -> NUM .)
    SEMI            reduce using rule 17 (factor -> NUM .)


state 7

    (2) program -> INT MAIN . LPAREN RPAREN LCB stmt_list return_stmt RCB
    LPAREN          shift and go to state 12


state 8

    (12) expr -> factor / . expr
    (11) expr -> . factor
    (12) expr -> . factor / expr
    (13) expr -> . factor * expr
    (14) expr -> . factor - expr
    (15) expr -> . factor + expr
    (16) factor -> . ID
    (17) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    factor                         shift and go to state 4
    expr                           shift and go to state 13

state 9

    (13) expr -> factor * . expr
    (11) expr -> . factor
    (12) expr -> . factor / expr
    (13) expr -> . factor * expr
    (14) expr -> . factor - expr
    (15) expr -> . factor + expr
    (16) factor -> . ID
    (17) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    factor                         shift and go to state 4
    expr                           shift and go to state 14

state 10

    (14) expr -> factor - . expr
    (11) expr -> . factor
    (12) expr -> . factor / expr
    (13) expr -> . factor * expr
    (14) expr -> . factor - expr
    (15) expr -> . factor + expr
    (16) factor -> . ID
    (17) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    factor                         shift and go to state 4
    expr                           shift and go to state 15

state 11

    (15) expr -> factor + . expr
    (11) expr -> . factor
    (12) expr -> . factor / expr
    (13) expr -> . factor * expr
    (14) expr -> . factor - expr
    (15) expr -> . factor + expr
    (16) factor -> . ID
    (17) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    factor                         shift and go to state 4
    expr                           shift and go to state 16

state 12

    (2) program -> INT MAIN LPAREN . RPAREN LCB stmt_list return_stmt RCB
    RPAREN          shift and go to state 17


state 13

    (12) expr -> factor / expr .
    $end            reduce using rule 12 (expr -> factor / expr .)
    RPAREN          reduce using rule 12 (expr -> factor / expr .)
    SEMI            reduce using rule 12 (expr -> factor / expr .)


state 14

    (13) expr -> factor * expr .
    $end            reduce using rule 13 (expr -> factor * expr .)
    RPAREN          reduce using rule 13 (expr -> factor * expr .)
    SEMI            reduce using rule 13 (expr -> factor * expr .)


state 15

    (14) expr -> factor - expr .
    $end            reduce using rule 14 (expr -> factor - expr .)
    RPAREN          reduce using rule 14 (expr -> factor - expr .)
    SEMI            reduce using rule 14 (expr -> factor - expr .)


state 16

    (15) expr -> factor + expr .
    $end            reduce using rule 15 (expr -> factor + expr .)
    RPAREN          reduce using rule 15 (expr -> factor + expr .)
    SEMI            reduce using rule 15 (expr -> factor + expr .)


state 17

    (2) program -> INT MAIN LPAREN RPAREN . LCB stmt_list return_stmt RCB
    LCB             shift and go to state 18


state 18

    (2) program -> INT MAIN LPAREN RPAREN LCB . stmt_list return_stmt RCB
    (3) stmt_list -> . stmt
    (4) stmt_list -> . stmt stmt_list
    (5) stmt -> . LPAREN expr RPAREN
    (6) stmt -> .
    (7) stmt -> . ID ASSIGN NUM SEMI
    (8) stmt -> . INT ID SEMI
    (9) stmt -> . INT ID ASSIGN expr SEMI
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
    LPAREN          shift and go to state 20
    RETURN          reduce using rule 6 (stmt -> .)
    ID              shift and go to state 23
    INT             shift and go to state 19

    stmt_list                      shift and go to state 21
    stmt                           shift and go to state 22

state 19

    (8) stmt -> INT . ID SEMI
    (9) stmt -> INT . ID ASSIGN expr SEMI
    ID              shift and go to state 24


state 20

    (5) stmt -> LPAREN . expr RPAREN
    (11) expr -> . factor
    (12) expr -> . factor / expr
    (13) expr -> . factor * expr
    (14) expr -> . factor - expr
    (15) expr -> . factor + expr
    (16) factor -> . ID
    (17) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    expr                           shift and go to state 25
    factor                         shift and go to state 4

state 21

    (2) program -> INT MAIN LPAREN RPAREN LCB stmt_list . return_stmt RCB
    (10) return_stmt -> . RETURN factor SEMI
    RETURN          shift and go to state 27

    return_stmt                    shift and go to state 26

state 22

    (3) stmt_list -> stmt .
    (4) stmt_list -> stmt . stmt_list
    (3) stmt_list -> . stmt
    (4) stmt_list -> . stmt stmt_list
    (5) stmt -> . LPAREN expr RPAREN
    (6) stmt -> .
    (7) stmt -> . ID ASSIGN NUM SEMI
    (8) stmt -> . INT ID SEMI
    (9) stmt -> . INT ID ASSIGN expr SEMI
  ! shift/reduce conflict for LPAREN resolved as shift
  ! reduce/reduce conflict for RETURN resolved using rule 3 (stmt_list -> stmt .)
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
    RETURN          reduce using rule 3 (stmt_list -> stmt .)
    LPAREN          shift and go to state 20
    ID              shift and go to state 23
    INT             shift and go to state 19

    stmt                           shift and go to state 22
    stmt_list                      shift and go to state 28

state 23

    (7) stmt -> ID . ASSIGN NUM SEMI
    ASSIGN          shift and go to state 29


state 24

    (8) stmt -> INT ID . SEMI
    (9) stmt -> INT ID . ASSIGN expr SEMI
    SEMI            shift and go to state 30
    ASSIGN          shift and go to state 31


state 25

    (5) stmt -> LPAREN expr . RPAREN
    RPAREN          shift and go to state 32


state 26

    (2) program -> INT MAIN LPAREN RPAREN LCB stmt_list return_stmt . RCB
    RCB             shift and go to state 33


state 27

    (10) return_stmt -> RETURN . factor SEMI
    (16) factor -> . ID
    (17) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    factor                         shift and go to state 34

state 28

    (4) stmt_list -> stmt stmt_list .
    RETURN          reduce using rule 4 (stmt_list -> stmt stmt_list .)


state 29

    (7) stmt -> ID ASSIGN . NUM SEMI
    NUM             shift and go to state 35


state 30

    (8) stmt -> INT ID SEMI .
    LPAREN          reduce using rule 8 (stmt -> INT ID SEMI .)
    ID              reduce using rule 8 (stmt -> INT ID SEMI .)
    INT             reduce using rule 8 (stmt -> INT ID SEMI .)
    RETURN          reduce using rule 8 (stmt -> INT ID SEMI .)


state 31

    (9) stmt -> INT ID ASSIGN . expr SEMI
    (11) expr -> . factor
    (12) expr -> . factor / expr
    (13) expr -> . factor * expr
    (14) expr -> . factor - expr
    (15) expr -> . factor + expr
    (16) factor -> . ID
    (17) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    expr                           shift and go to state 36
    factor                         shift and go to state 4

state 32

    (5) stmt -> LPAREN expr RPAREN .
    LPAREN          reduce using rule 5 (stmt -> LPAREN expr RPAREN .)
    ID              reduce using rule 5 (stmt -> LPAREN expr RPAREN .)
    INT             reduce using rule 5 (stmt -> LPAREN expr RPAREN .)
    RETURN          reduce using rule 5 (stmt -> LPAREN expr RPAREN .)


state 33

    (2) program -> INT MAIN LPAREN RPAREN LCB stmt_list return_stmt RCB .
    $end            reduce using rule 2 (program -> INT MAIN LPAREN RPAREN LCB stmt_list return_stmt RCB .)


state 34

    (10) return_stmt -> RETURN factor . SEMI
    SEMI            shift and go to state 37


state 35

    (7) stmt -> ID ASSIGN NUM . SEMI
    SEMI            shift and go to state 38


state 36

    (9) stmt -> INT ID ASSIGN expr . SEMI
    SEMI            shift and go to state 39


state 37

    (10) return_stmt -> RETURN factor SEMI .
    RCB             reduce using rule 10 (return_stmt -> RETURN factor SEMI .)


state 38

    (7) stmt -> ID ASSIGN NUM SEMI .
    LPAREN          reduce using rule 7 (stmt -> ID ASSIGN NUM SEMI .)
    ID              reduce using rule 7 (stmt -> ID ASSIGN NUM SEMI .)
    INT             reduce using rule 7 (stmt -> ID ASSIGN NUM SEMI .)
    RETURN          reduce using rule 7 (stmt -> ID ASSIGN NUM SEMI .)


state 39

    (9) stmt -> INT ID ASSIGN expr SEMI .
    LPAREN          reduce using rule 9 (stmt -> INT ID ASSIGN expr SEMI .)
    ID              reduce using rule 9 (stmt -> INT ID ASSIGN expr SEMI .)
    INT             reduce using rule 9 (stmt -> INT ID ASSIGN expr SEMI .)
    RETURN          reduce using rule 9 (stmt -> INT ID ASSIGN expr SEMI .)


Conflicts:

shift/reduce conflict for LPAREN in state 18 resolved as shift
shift/reduce conflict for ID in state 18 resolved as shift
shift/reduce conflict for INT in state 18 resolved as shift
shift/reduce conflict for LPAREN in state 22 resolved as shift
shift/reduce conflict for ID in state 22 resolved as shift
shift/reduce conflict for INT in state 22 resolved as shift
reduce/reduce conflict in state 22 resolved using rule stmt_list -> stmt
rejected rule (stmt -> <empty>) in state 22