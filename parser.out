Grammar:

Rule 0     S' -> program
Rule 1     program -> expr
Rule 2     program -> INT MAIN LPAREN RPAREN LCB stmt_list return_stmt RCB
Rule 3     stmt_list -> stmt
Rule 4     stmt_list -> stmt stmt_list
Rule 5     stmt -> LPAREN expr RPAREN
Rule 6     stmt -> empty
Rule 7     stmt -> ID ASSIGN NUM SEMI
Rule 8     stmt -> INT ID SEMI
Rule 9     stmt -> INT ID ASSIGN expr SEMI
Rule 10    empty -> <empty>
Rule 11    return_stmt -> RETURN factor SEMI
Rule 12    expr -> factor
Rule 13    expr -> factor / expr  [precedence=left, level=2]
Rule 14    expr -> factor * expr  [precedence=left, level=2]
Rule 15    expr -> factor - expr  [precedence=left, level=1]
Rule 16    expr -> factor + expr  [precedence=left, level=1]
Rule 17    factor -> ID
Rule 18    factor -> NUM

Unused terminals:

    CHAR
    LOGICOR
    EQREL
    NEGATE
    CASE
    SIZEOF
    BREAK
    EXTERN
    SWITCH
    IF
    DECREMNT
    INCRMNT
    INLINE
    GRTEQ
    LTR
    COMPLEX
    FLOAT
    LOGICAND
    DO
    VOLATILE
    LONG
    SIGNED
    DEFAULT
    BOOL
    IMAGINARY
    DOUBLE
    WHILE
    ENUM
    REGISTER
    UNION
    NOTEQ
    SHORT
    UNSIGNED
    CONTINUE
    TYPEDEF
    LESEQ
    CONST
    STRUCT
    VOID
    GOTO
    FOR
    ELSE
    AUTO
    GTR
    STATIC

Terminals, with rules where they appear:

*                    : 14
+                    : 16
-                    : 15
/                    : 13
ASSIGN               : 7 9
AUTO                 : 
BOOL                 : 
BREAK                : 
CASE                 : 
CHAR                 : 
COMPLEX              : 
CONST                : 
CONTINUE             : 
DECREMNT             : 
DEFAULT              : 
DO                   : 
DOUBLE               : 
ELSE                 : 
ENUM                 : 
EQREL                : 
EXTERN               : 
FLOAT                : 
FOR                  : 
GOTO                 : 
GRTEQ                : 
GTR                  : 
ID                   : 7 8 9 17
IF                   : 
IMAGINARY            : 
INCRMNT              : 
INLINE               : 
INT                  : 2 8 9
LCB                  : 2
LESEQ                : 
LOGICAND             : 
LOGICOR              : 
LONG                 : 
LPAREN               : 2 5
LTR                  : 
MAIN                 : 2
NEGATE               : 
NOTEQ                : 
NUM                  : 7 18
RCB                  : 2
REGISTER             : 
RETURN               : 11
RPAREN               : 2 5
SEMI                 : 7 8 9 11
SHORT                : 
SIGNED               : 
SIZEOF               : 
STATIC               : 
STRUCT               : 
SWITCH               : 
TYPEDEF              : 
UNION                : 
UNSIGNED             : 
VOID                 : 
VOLATILE             : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear:

empty                : 6
expr                 : 1 5 9 13 14 15 16
factor               : 11 12 13 14 15 16
program              : 0
return_stmt          : 2
stmt                 : 3 4
stmt_list            : 2 4


state 0

    (0) S' -> . program
    (1) program -> . expr
    (2) program -> . INT MAIN LPAREN RPAREN LCB stmt_list return_stmt RCB
    (12) expr -> . factor
    (13) expr -> . factor / expr
    (14) expr -> . factor * expr
    (15) expr -> . factor - expr
    (16) expr -> . factor + expr
    (17) factor -> . ID
    (18) factor -> . NUM
    INT             shift and go to state 3
    ID              shift and go to state 5
    NUM             shift and go to state 6

    program                        shift and go to state 1
    expr                           shift and go to state 2
    factor                         shift and go to state 4

state 1

    (0) S' -> program .


state 2

    (1) program -> expr .
    $end            reduce using rule 1 (program -> expr .)


state 3

    (2) program -> INT . MAIN LPAREN RPAREN LCB stmt_list return_stmt RCB
    MAIN            shift and go to state 7


state 4

    (12) expr -> factor .
    (13) expr -> factor . / expr
    (14) expr -> factor . * expr
    (15) expr -> factor . - expr
    (16) expr -> factor . + expr
    $end            reduce using rule 12 (expr -> factor .)
    RPAREN          reduce using rule 12 (expr -> factor .)
    SEMI            reduce using rule 12 (expr -> factor .)
    /               shift and go to state 8
    *               shift and go to state 9
    -               shift and go to state 10
    +               shift and go to state 11


state 5

    (17) factor -> ID .
    /               reduce using rule 17 (factor -> ID .)
    *               reduce using rule 17 (factor -> ID .)
    -               reduce using rule 17 (factor -> ID .)
    +               reduce using rule 17 (factor -> ID .)
    $end            reduce using rule 17 (factor -> ID .)
    RPAREN          reduce using rule 17 (factor -> ID .)
    SEMI            reduce using rule 17 (factor -> ID .)


state 6

    (18) factor -> NUM .
    /               reduce using rule 18 (factor -> NUM .)
    *               reduce using rule 18 (factor -> NUM .)
    -               reduce using rule 18 (factor -> NUM .)
    +               reduce using rule 18 (factor -> NUM .)
    $end            reduce using rule 18 (factor -> NUM .)
    RPAREN          reduce using rule 18 (factor -> NUM .)
    SEMI            reduce using rule 18 (factor -> NUM .)


state 7

    (2) program -> INT MAIN . LPAREN RPAREN LCB stmt_list return_stmt RCB
    LPAREN          shift and go to state 12


state 8

    (13) expr -> factor / . expr
    (12) expr -> . factor
    (13) expr -> . factor / expr
    (14) expr -> . factor * expr
    (15) expr -> . factor - expr
    (16) expr -> . factor + expr
    (17) factor -> . ID
    (18) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    factor                         shift and go to state 4
    expr                           shift and go to state 13

state 9

    (14) expr -> factor * . expr
    (12) expr -> . factor
    (13) expr -> . factor / expr
    (14) expr -> . factor * expr
    (15) expr -> . factor - expr
    (16) expr -> . factor + expr
    (17) factor -> . ID
    (18) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    factor                         shift and go to state 4
    expr                           shift and go to state 14

state 10

    (15) expr -> factor - . expr
    (12) expr -> . factor
    (13) expr -> . factor / expr
    (14) expr -> . factor * expr
    (15) expr -> . factor - expr
    (16) expr -> . factor + expr
    (17) factor -> . ID
    (18) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    factor                         shift and go to state 4
    expr                           shift and go to state 15

state 11

    (16) expr -> factor + . expr
    (12) expr -> . factor
    (13) expr -> . factor / expr
    (14) expr -> . factor * expr
    (15) expr -> . factor - expr
    (16) expr -> . factor + expr
    (17) factor -> . ID
    (18) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    factor                         shift and go to state 4
    expr                           shift and go to state 16

state 12

    (2) program -> INT MAIN LPAREN . RPAREN LCB stmt_list return_stmt RCB
    RPAREN          shift and go to state 17


state 13

    (13) expr -> factor / expr .
    $end            reduce using rule 13 (expr -> factor / expr .)
    RPAREN          reduce using rule 13 (expr -> factor / expr .)
    SEMI            reduce using rule 13 (expr -> factor / expr .)


state 14

    (14) expr -> factor * expr .
    $end            reduce using rule 14 (expr -> factor * expr .)
    RPAREN          reduce using rule 14 (expr -> factor * expr .)
    SEMI            reduce using rule 14 (expr -> factor * expr .)


state 15

    (15) expr -> factor - expr .
    $end            reduce using rule 15 (expr -> factor - expr .)
    RPAREN          reduce using rule 15 (expr -> factor - expr .)
    SEMI            reduce using rule 15 (expr -> factor - expr .)


state 16

    (16) expr -> factor + expr .
    $end            reduce using rule 16 (expr -> factor + expr .)
    RPAREN          reduce using rule 16 (expr -> factor + expr .)
    SEMI            reduce using rule 16 (expr -> factor + expr .)


state 17

    (2) program -> INT MAIN LPAREN RPAREN . LCB stmt_list return_stmt RCB
    LCB             shift and go to state 18


state 18

    (2) program -> INT MAIN LPAREN RPAREN LCB . stmt_list return_stmt RCB
    (3) stmt_list -> . stmt
    (4) stmt_list -> . stmt stmt_list
    (5) stmt -> . LPAREN expr RPAREN
    (6) stmt -> . empty
    (7) stmt -> . ID ASSIGN NUM SEMI
    (8) stmt -> . INT ID SEMI
    (9) stmt -> . INT ID ASSIGN expr SEMI
    (10) empty -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
    LPAREN          shift and go to state 20
    ID              shift and go to state 24
    INT             shift and go to state 19
    RETURN          reduce using rule 10 (empty -> .)

    stmt_list                      shift and go to state 21
    stmt                           shift and go to state 22
    empty                          shift and go to state 23

state 19

    (8) stmt -> INT . ID SEMI
    (9) stmt -> INT . ID ASSIGN expr SEMI
    ID              shift and go to state 25


state 20

    (5) stmt -> LPAREN . expr RPAREN
    (12) expr -> . factor
    (13) expr -> . factor / expr
    (14) expr -> . factor * expr
    (15) expr -> . factor - expr
    (16) expr -> . factor + expr
    (17) factor -> . ID
    (18) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    expr                           shift and go to state 26
    factor                         shift and go to state 4

state 21

    (2) program -> INT MAIN LPAREN RPAREN LCB stmt_list . return_stmt RCB
    (11) return_stmt -> . RETURN factor SEMI
    RETURN          shift and go to state 28

    return_stmt                    shift and go to state 27

state 22

    (3) stmt_list -> stmt .
    (4) stmt_list -> stmt . stmt_list
    (3) stmt_list -> . stmt
    (4) stmt_list -> . stmt stmt_list
    (5) stmt -> . LPAREN expr RPAREN
    (6) stmt -> . empty
    (7) stmt -> . ID ASSIGN NUM SEMI
    (8) stmt -> . INT ID SEMI
    (9) stmt -> . INT ID ASSIGN expr SEMI
    (10) empty -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! reduce/reduce conflict for RETURN resolved using rule 3 (stmt_list -> stmt .)
    RETURN          reduce using rule 3 (stmt_list -> stmt .)
    LPAREN          shift and go to state 20
    ID              shift and go to state 24
    INT             shift and go to state 19

    stmt                           shift and go to state 22
    stmt_list                      shift and go to state 29
    empty                          shift and go to state 23

state 23

    (6) stmt -> empty .
    LPAREN          reduce using rule 6 (stmt -> empty .)
    ID              reduce using rule 6 (stmt -> empty .)
    INT             reduce using rule 6 (stmt -> empty .)
    RETURN          reduce using rule 6 (stmt -> empty .)


state 24

    (7) stmt -> ID . ASSIGN NUM SEMI
    ASSIGN          shift and go to state 30


state 25

    (8) stmt -> INT ID . SEMI
    (9) stmt -> INT ID . ASSIGN expr SEMI
    SEMI            shift and go to state 31
    ASSIGN          shift and go to state 32


state 26

    (5) stmt -> LPAREN expr . RPAREN
    RPAREN          shift and go to state 33


state 27

    (2) program -> INT MAIN LPAREN RPAREN LCB stmt_list return_stmt . RCB
    RCB             shift and go to state 34


state 28

    (11) return_stmt -> RETURN . factor SEMI
    (17) factor -> . ID
    (18) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    factor                         shift and go to state 35

state 29

    (4) stmt_list -> stmt stmt_list .
    RETURN          reduce using rule 4 (stmt_list -> stmt stmt_list .)


state 30

    (7) stmt -> ID ASSIGN . NUM SEMI
    NUM             shift and go to state 36


state 31

    (8) stmt -> INT ID SEMI .
    LPAREN          reduce using rule 8 (stmt -> INT ID SEMI .)
    ID              reduce using rule 8 (stmt -> INT ID SEMI .)
    INT             reduce using rule 8 (stmt -> INT ID SEMI .)
    RETURN          reduce using rule 8 (stmt -> INT ID SEMI .)


state 32

    (9) stmt -> INT ID ASSIGN . expr SEMI
    (12) expr -> . factor
    (13) expr -> . factor / expr
    (14) expr -> . factor * expr
    (15) expr -> . factor - expr
    (16) expr -> . factor + expr
    (17) factor -> . ID
    (18) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    expr                           shift and go to state 37
    factor                         shift and go to state 4

state 33

    (5) stmt -> LPAREN expr RPAREN .
    LPAREN          reduce using rule 5 (stmt -> LPAREN expr RPAREN .)
    ID              reduce using rule 5 (stmt -> LPAREN expr RPAREN .)
    INT             reduce using rule 5 (stmt -> LPAREN expr RPAREN .)
    RETURN          reduce using rule 5 (stmt -> LPAREN expr RPAREN .)


state 34

    (2) program -> INT MAIN LPAREN RPAREN LCB stmt_list return_stmt RCB .
    $end            reduce using rule 2 (program -> INT MAIN LPAREN RPAREN LCB stmt_list return_stmt RCB .)


state 35

    (11) return_stmt -> RETURN factor . SEMI
    SEMI            shift and go to state 38


state 36

    (7) stmt -> ID ASSIGN NUM . SEMI
    SEMI            shift and go to state 39


state 37

    (9) stmt -> INT ID ASSIGN expr . SEMI
    SEMI            shift and go to state 40


state 38

    (11) return_stmt -> RETURN factor SEMI .
    RCB             reduce using rule 11 (return_stmt -> RETURN factor SEMI .)


state 39

    (7) stmt -> ID ASSIGN NUM SEMI .
    LPAREN          reduce using rule 7 (stmt -> ID ASSIGN NUM SEMI .)
    ID              reduce using rule 7 (stmt -> ID ASSIGN NUM SEMI .)
    INT             reduce using rule 7 (stmt -> ID ASSIGN NUM SEMI .)
    RETURN          reduce using rule 7 (stmt -> ID ASSIGN NUM SEMI .)


state 40

    (9) stmt -> INT ID ASSIGN expr SEMI .
    LPAREN          reduce using rule 9 (stmt -> INT ID ASSIGN expr SEMI .)
    ID              reduce using rule 9 (stmt -> INT ID ASSIGN expr SEMI .)
    INT             reduce using rule 9 (stmt -> INT ID ASSIGN expr SEMI .)
    RETURN          reduce using rule 9 (stmt -> INT ID ASSIGN expr SEMI .)


Conflicts:

shift/reduce conflict for LPAREN in state 18 resolved as shift
shift/reduce conflict for ID in state 18 resolved as shift
shift/reduce conflict for INT in state 18 resolved as shift
shift/reduce conflict for LPAREN in state 22 resolved as shift
shift/reduce conflict for ID in state 22 resolved as shift
shift/reduce conflict for INT in state 22 resolved as shift
reduce/reduce conflict in state 22 resolved using rule stmt_list -> stmt
rejected rule (empty -> <empty>) in state 22